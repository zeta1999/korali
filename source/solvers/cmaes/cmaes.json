{
 "Name": "Covariance Matrix Adaptation Evolution Strategy",
 "Alias": "CMAES",
 "Class": "CMAES",
 
 "Solver Configuration": 
 [
   {
    "Name": [ "Population Size" ],
    "Type": "size_t",
    "Description": "Specifies the number of samples to evaluate per generation (preferably $4+3*log(N)$, where $N$ is the number of variables)."
   },
   {
    "Name": [ "Mu Value" ],
    "Default": "_populationSize*0.5",
    "Type": "size_t",
    "Description": "Number of best samples used to update the covariance matrix and the mean (by default it is half the Sample Count)."
   },
   {
    "Name": [ "Mu Type" ],
    "Default": "Logarithmic",
    "Type": "std::string",
    "Description": "Weights given to the Mu best values to update the covariance matrix and the mean (possible options are 'Linear', 'Equal' or 'Logarithmic')."
   },
   {
    "Name": [ "Initial Sigma Cumulation Factor" ],
    "Default": "-1.0",
    "Type": "double",
    "Description": "Controls the learning rate of the conjugate evolution path (by default this variable is internally calibrated)."
   },
   {
    "Name": [ "Initial Damp Factor" ],
    "Default": "-1.0",
    "Type": "double",
    "Description": "Controls the updates of the covariance matrix scaling factor (by default this variable is internally calibrated)."
   },
   {
    "Name": [ "Is Sigma Bounded" ],
    "Default": "false",
    "Type": "bool",
    "Description": "Sets an upper bound for the covariance matrix scaling factor. The upper bound is given by the average of the initial standard deviation of the variables."
   },
   {
    "Name": [ "Initial Cumulative Covariance" ],
    "Default": "-1.0",
    "Type": "double",
    "Description": "Controls the learning rate of the evolution path for the covariance update (must be in (0,1], by default this variable is internally calibrated)."
   },
   {
    "Name": [ "Is Diagonal" ],
    "Default": "false",
    "Type": "bool",
    "Description": "Covariance matrix updates will be optimized for diagonal matrices."
   },
   {
    "Name": [ "Viability Population Size" ],
    "Default": "2",
    "Type": "size_t",
    "Description": "Specifies the number of samples per generation during the viability regime, i.e. during the search for a parameter vector not violating the constraints."
   },
   {
    "Name": [ "Viability Mu Value" ],
    "Default": "_viabilityPopulationSize*0.5",
    "Type": "size_t",
    "Description": "Number of best samples used to update the covariance matrix and the mean during the viability regime (by default this variable is hald the Viability Sample Count)."
   },
   {
    "Name": [ "Max Covariance Matrix Corrections" ],
    "Default": "1e6",
    "Type": "size_t",
    "Description": "Max number of covairance matrix adaptions per generation during the constraint handling loop."
   },
   {
    "Name": [ "Target Success Rate" ],
    "Default": "0.1818",
    "Type": "double",
    "Description": "Controls the updates of the covariance matrix scaling factor during the viability regime."
   },
   {
    "Name": [ "Covariance Matrix Adaption Strength" ],
    "Default": "0.1",
    "Type": "double",
    "Description": "Controls the covariane matrix adaption strength if samples violate constraints."
   },
   {
    "Name": [ "Normal Vector Learning Rate" ],
    "Default": "-1.0",
    "Type": "double",
    "Description": "Learning rate of constraint normal vectors (must be in (0, 1], by default this variable is internally calibrated)."
   },
   {
    "Name": [ "Global Success Learning Rate" ],
    "Default": "0.2",
    "Type": "double",
    "Description": "Learning rate of success probability of objective function improvements."
   }
 ],
 
 "Termination Criteria":
 [
   {
    "Name": [ "Max Generations" ],
    "Type": "size_t",
    "Default": "200",
    "Criteria": "_k->_currentGeneration >= _maxGenerations",
    "Description": "Determines how many solver generations to run before stopping execution. Execution can be resumed at a later moment."
   },
   {
    "Name": [ "Max Model Evaluations" ],
    "Type": "size_t",
    "Default": "+INFINITY",
    "Criteria": "_k->_computationalModelEvaluationCount > _maxModelEvaluations",
    "Description": "Determines how many computational model evaluations to run before stopping execution. Execution can be resumed at a later moment."
   },
   {
    "Name": [ "Max Infeasible Resamplings" ],
    "Type": "size_t",
    "Default": "+INFINITY",
    "Criteria": "_infeasibleSampleCount >= _maxInfeasibleResamplings",
    "Description": "Maximum number of resamplings per candidate per generation if sample is outside of Lower and Upper Bound."
   },
   {
    "Name": [ "Max Condition Covariance Matrix" ],
    "Type": "double",
    "Default": "+INFINITY",
    "Criteria": "_maximumCovarianceEigenvalue >= _minimumCovarianceEigenvalue * _maxConditionCovarianceMatrix",
    "Description": "Specifies the maximum condition of the covariance matrix."
   },
   {
    "Name": [ "Min Value" ], 
    "Type": "double",
    "Default": "-std::numeric_limits<double>::infinity()",
    "Criteria": "_bestEverValue < _minValue",
    "Description": "Specifies the minimum target fitness to stop minimization."
   },
   {
    "Name": [ "Max Value" ],
    "Type": "double",
    "Default": "+INFINITY",
    "Criteria": "_bestEverValue > _maxValue",
    "Description": "Specifies the maximum target fitness to stop maximization."
   },
   {
    "Name": [ "Min Value Difference Threshold" ],
    "Type": "double",
    "Default": "-std::numeric_limits<double>::infinity()",
    "Criteria": "_k->_hasComputedGeneration && (fabs(_currentBestValue - _previousBestValue) <= _minValueDifferenceThreshold)",
    "Description": "Specifies the minimum fitness differential between two consecutive generations before stopping execution."
   },
   {
    "Name": [ "Min Standard Deviation" ],
    "Type": "double",
    "Default": "-std::numeric_limits<double>::infinity()",
    "Criteria": "_currentMinStandardDeviation < _minStandardDeviation",
    "Description": "Specifies the minimal standard deviation for any variable in any proposed sample."
   },
   {
    "Name": [ "Max Standard Deviation" ],
    "Type": "double",
    "Default": "+INFINITY",
    "Criteria": "_currentMaxStandardDeviation > _maxStandardDeviation",
    "Description": "Specifies the maximal standard deviation for any variable in any proposed sample."
   },
   {
    "Name": [ "Min Standard Deviation Step Factor" ],
    "Type": "double",
    "Default": "-std::numeric_limits<double>::infinity()",
    "Criteria": "_k->_hasComputedGeneration && (_currentMinStandardDeviationStep < _minStandardDeviationStepFactor)",
    "Description": "Specifies the minimum standard deviation in the direction of the eigenvectors."
   }
 ],
 
 "Variables Configuration": 
 [
   {
    "Name": [ "Lower Bound" ],
    "Type": "double",
    "Default": "NAN",
    "Description": "Specifies the lower bound for the variable's value. Korali will not generate samples for which its value falls below the Lower Bound."
   },
   {
    "Name": [ "Upper Bound" ],
    "Type": "double",
    "Default": "NAN",
    "Description": "Specifies the upper bound for the variable's value. Korali will not generate samples for which its value falls above the Upper Bound."
   },
   {
    "Name": [ "Initial Mean" ],
    "Type": "double",
    "Default": "(_upperBound + _lowerBound)*0.5",
    "Description": "Defines the initial mean for the proposal distribution. This value must be defined between the variable's Mininum and Maximum settings (by default, this value is given by the center of the variable domain)."
   },
   {
    "Name": [ "Initial Standard Deviation" ],
    "Type": "double",
    "Default": "(_upperBound - _lowerBound)*0.3",
    "Description": "Defines the initial standard deviation of the proposal distribution for a variable (by default, this value is given by 30% of the variable domain width)."
   },
   {
    "Name": [ "Minimum Standard Deviation Update" ],
    "Type": "double",
    "Default": "0.0",
    "Description": "Defines a lower bound for the standard deviation updates of the proposal distribution for a variable. Korali increases the scaling factor $\\sigma$ if this value is undershot."
   },
   {
    "Name": [ "Is Discrete" ],
    "Type": "bool",
    "Default": "false",
    "Description": "Specifies if the variable can only take discrete values within the range of the lower and upper bound."
   },
   {
    "Name": [ "Granularity" ],
    "Type": "double",
    "Default": "0.0",
    "Description": "Specifies the granulatiry of a discrete variable, a granularity of 1.0 means that the variable can only take values in (.., -1.0, 0.0, +1.0, +2.0, ..) where the levels are set symmetric around the initial mean (here 0.0)."
   }
 ],
 
 "Internal Settings": 
 [
   {
    "Name": [ "Is Viability Regime" ],
    "Type": "bool",
    "Description": "True if mean is outside feasible domain."
   },
   {
    "Name": [ "Value Vector" ],
    "Type": "std::vector<double>",
    "Description": "Objective function values."
   },
   {
    "Name": [ "Previous Value Vector" ],
    "Type": "std::vector<double>",
    "Description": "Objective function values from previous generation."
   },
   {
    "Name": [ "Current Population Size" ],
    "Type": "size_t",
    "Description": "Actual number of samples used per generation (Population Size or Viability Population Size)."
   },
   {
    "Name": [ "Current Mu Value" ],
    "Type": "size_t",
    "Description": "Actual value of mu (Mu Value or Viability Mu Value)."
   },
   {
    "Name": [ "Mu Weights" ],
    "Type": "std::vector<double>",
    "Description": "Weights for each of the Mu samples."
   },
   {
    "Name": [ "Effective Mu" ],
    "Type": "double",
    "Description": "Variance effective selection mass."
   },
   {
    "Name": [ "Sigma Cumulation Factor" ],
    "Type": "double",
    "Description": "Increment for sigma, calculated from muEffective and dimension."
   },
   {
    "Name": [ "Damp Factor" ],
    "Type": "double",
    "Description": "Dampening parameter controls step size adaption."
   },
   {
    "Name": [ "Cumulative Covariance" ],
    "Type": "double",
    "Description": "Controls the step size adaption."
   },
   {
    "Name": [ "Chi Square Number" ],
    "Type": "double",
    "Description": "Expectation of $||N(0,I)||^2$."
   },
   {
    "Name": [ "Covariance Eigenvalue Evaluation Frequency" ],
    "Type": "size_t",
    "Description": "Establishes how frequently the eigenvalues are updated."
   },
   {
    "Name": [ "Sigma" ],
    "Type": "double",
    "Description": "Determines the step size."
   },
   {
    "Name": [ "Trace" ],
    "Type": "double",
    "Description": "The trace of the initial covariance matrix."
   },
   {
    "Name": [ "Sample Population" ],
    "Type": "std::vector<double>",
    "Description": "Sample coordinate information."
   },
   {
    "Name": [ "Is Initialized Sample" ],
    "Type": "std::vector<bool>",
    "Description": "Determines which samples are initialized."
   },
   {
    "Name": [ "Finished Sample Count" ],
    "Type": "size_t",
    "Description": "Counter of evaluated samples to terminate evaluation."
   },
   {
    "Name": [ "Current Best Value" ],
    "Type": "double",
    "Description": "Best model evaluation from current generation."
   },
   {
    "Name": [ "Current Best Variables" ],
    "Type": "std::vector<double>",
    "Description": "Best variables of current generation."
   },
   {
    "Name": [ "Best Ever Variables" ],
    "Type": "std::vector<double>",
    "Description": "Best ever found variables."
   },
   {
    "Name": [ "Previous Best Value" ],
    "Type": "double",
    "Description": "Best model evaluation from previous generation."
   },
   {
    "Name": [ "Best Sample Index" ],
    "Type": "size_t",
    "Description": "Index of the best sample in current generation."
   },
   {
    "Name": [ "Best Ever Value" ],
    "Type": "double",
    "Description": "Best ever model evaluation."
   },
   {
    "Name": [ "Previous Best Ever Value" ],
    "Type": "double",
    "Description": "Best ever model evaluation as of previous generation."
   },
   {
    "Name": [ "Sorting Index" ],
    "Type": "std::vector<size_t>",
    "Description": "Sorted indeces of samples according to their model evaluation."
   },
   {
    "Name": [ "Covariance Matrix" ],
    "Type": "std::vector<double>",
    "Description": "(Unscaled) covariance Matrix of proposal distribution."
   },
   {
    "Name": [ "Auxiliar Covariance Matrix" ],
    "Type": "std::vector<double>",
    "Description": "Temporary Storage for Covariance Matrix."
   },
   {
    "Name": [ "Covariance Eigenvector Matrix" ],
    "Type": "std::vector<double>",
    "Description": "Matrix with eigenvectors in columns."
   },
   {
    "Name": [ "Auxiliar Covariance Eigenvector Matrix" ],
    "Type": "std::vector<double>",
    "Description": "Temporary Storage for Matrix with eigenvectors in columns."
   },
   {
    "Name": [ "Axis Lengths" ],
    "Type": "std::vector<double>",
    "Description": "Axis lengths (sqrt(Evals))"
   },
   {
    "Name": [ "Auxiliar Axis Lengths" ],
    "Type": "std::vector<double>",
    "Description": "Temporary storage for Axis lengths."
   },
   {
    "Name": [ "Random Number Storage" ],
    "Type": "std::vector<double>",
    "Description": "Temporary storage for Random Number Generation."
   },
   {
    "Name": [ "BDZ Matrix" ],
    "Type": "std::vector<double>",
    "Description": "Temporary storage."
   },
   {
    "Name": [ "Auxiliar BDZ Matrix" ] ,
    "Type": "std::vector<double>",
    "Description": "Temporary storage."
   },
   {
    "Name": [ "Current Mean" ],
    "Type": "std::vector<double>",
    "Description": "Current mean of proposal distribution."
   },
   {
    "Name": [ "Previous Mean" ],
    "Type": "std::vector<double>",
    "Description": "Previous mean of proposal distribution."
   },
   {
    "Name": [ "Mean Update" ],
    "Type": "std::vector<double>",
    "Description": "Update differential from previous to current mean."
   },
   {
    "Name": [ "Evolution Path" ],
    "Type": "std::vector<double>",
    "Description": "Evolution path for Covariance Matrix update."
   },
   {
    "Name": [ "Conjugate Evolution Path" ],
    "Type": "std::vector<double>",
    "Description": "Conjugate evolution path for sigma update."
   },
   {
    "Name": [ "Conjugate Evolution Path L2 Norm" ],
    "Type": "double",
    "Description": "L2 Norm of the conjugate evolution path."
   },
   {
    "Name": [ "Infeasible Sample Count" ],
    "Type": "size_t",
    "Description": "Keeps count of the number of function evaluations so far."
   },
   {
    "Name": [ "Maximum Diagonal Covariance Matrix Element" ],
    "Type": "double",
    "Description": "Maximum diagonal element of the Covariance Matrix."
   },
   {
    "Name": [ "Minimum Diagonal Covariance Matrix Element" ],
    "Type": "double",
    "Description": "Minimum diagonal element of the Covariance Matrix."
   },
   {
    "Name": [ "Maximum Covariance Eigenvalue" ],
    "Type": "double",
    "Description": "Maximum Covariance Matrix Eigenvalue."
   },
   {
    "Name": [ "Minimum Covariance Eigenvalue" ],
    "Type": "double",
    "Description": "Minimum Covariance Matrix Eigenvalue."
   },
   {
    "Name": [ "Is Eigensystem Updated" ],
    "Type": "bool",
    "Description": "Flag determining if the covariance eigensystem is up to date."
   },
   {
    "Name": [ "Viability Indicator" ],
    "Type": "std::vector<std::vector<bool>>",
    "Description": "Evaluation of each constraint for each sample."
   },
   {
    "Name": [ "Are Constraints Defined" ],
    "Type": "bool",
    "Description": "True if the number of constraints is higher than zero."
   },
   {
    "Name": [ "Covariance Matrix Adaption Factor" ],
    "Type": "double",
    "Description": "This is the $\beta$ factor that indicates how fast the covariance matrix is adapted."
   },
   {
    "Name": [ "Best Valid Sample" ],
    "Type": "int",
    "Description": "Index of best sample without constraint violations (otherwise -1)."
   },
   {
    "Name": [ "Global Success Rate" ],
    "Type": "double",
    "Description": "Estimated Global Success Rate, required for calibration of covariance matrix scaling factor updates."
   },
   {
    "Name": [ "Viability Function Value" ],
    "Type": "double",
    "Description": "Viability Function Value."
   },
   {
    "Name": [ "Resampled Parameter Count" ],
    "Type": "size_t",
    "Description": "Number of resampled parameters due constraint violation."
   },
   {
    "Name": [ "Covariance Matrix Adaptation Count" ],
    "Type": "size_t",
    "Description": "Number of Covariance Matrix Adaptations."
   },
   {
    "Name": [ "Constraint Evaluation Count" ],
    "Type": "size_t",
    "Description": "Number of Covariance Matrix Adaptations."
   },
   {
    "Name": [ "Viability Boundaries" ],
    "Type": "std::vector<double>",
    "Description": "Viability Boundaries."
   },
   {
    "Name": [ "Viability Improvement" ],
    "Type": "std::vector<bool>",
    "Description": "Sample evaluations larger than fviability."
   },
   {
    "Name": [ "Maximum Violation Count" ],
    "Type": "size_t",
    "Description": "Maximal amount of constraint violations."
   },
   {
    "Name": [ "Sample Constraint Violation Counts" ],
    "Type": "std::vector<size_t>",
    "Description": "Maximal amount of constraint violations."
   },
   {
    "Name": [ "Constraint Evaluations" ],
    "Type": "std::vector<std::vector<double>>",
    "Description": "Constraint Evaluations $$e$$."
   },
   {
    "Name": [ "Normal Constraint Approximation" ],
    "Type": "std::vector<std::vector<double>>",
    "Description": "Normal approximation of constraints."
   },
   {
    "Name": [ "Best Constraint Evaluations" ],
    "Type": "std::vector<double>",
    "Description": "Constraint evaluations for best ever."
   },
   {
    "Name": [ "Has Discrete Variables" ],
    "Type": "bool",
    "Description": "Flag indicating if at least one of the variables is discrete."
   },
   {
    "Name": [ "Discrete Mutations" ],
    "Type": "std::vector<double>",
    "Description": "Vector storing discrete mutations, required for covariance matrix update."
   },
   {
    "Name": [ "Number Of Discrete Mutations" ],
    "Type": "size_t",
    "Description": "Number of discrete mutations in current generation."
   },
   {
    "Name": [ "Granularity" ],
    "Type": "std::vector<double>",
    "Description": "Flag determining if the covariance eigensystem is up to date."
   },
   {
    "Name": [ "Number Masking Matrix Entries" ],
    "Type": "size_t",
    "Description": "Number of nonzero entries on diagonal in Masking Matrix."
   },
   {
    "Name": [ "Masking Matrix" ],
    "Type": "std::vector<double>",
    "Description": "Diagonal Matrix signifying where an integer mutation may be conducted."
   },
   {
    "Name": [ "Masking Matrix Sigma" ],
    "Type": "std::vector<double>",
    "Description": "Sigma of the Masking Matrix."
   },
   {
    "Name": [ "Chi Square Number Discrete Mutations" ],
    "Type": "double",
    "Description": "Expectation of $||N(0,I^S)||^2$ for discrete mutations."
   },
   {
    "Name": [ "Current Min Standard Deviation" ],
    "Type": "double",
    "Description": "Current minimum standard deviation of any variable."
   },
   {
    "Name": [ "Current Max Standard Deviation" ],
    "Type": "double",
    "Description": "Current maximum standard deviation of any variable."
   },
   {
    "Name": [ "Current Min Standard Deviation Step" ],
    "Type": "double",
    "Description": "Current minimum standard deviation step of any variable."
   }
 ]
}
