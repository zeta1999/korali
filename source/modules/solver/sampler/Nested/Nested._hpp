#ifndef _KORALI_SOLVER_NESTED_HPP_
#define _KORALI_SOLVER_NESTED_HPP_

#include "modules/distribution/multivariate/normal/normal.hpp"
#include "modules/distribution/univariate/normal/normal.hpp"
#include "modules/distribution/univariate/uniform/uniform.hpp"
#include "modules/solver/sampler/sampler.hpp"
#include <vector>

namespace korali
{
namespace solver
{
namespace sampler
{
struct ellipse_t
{
  ellipse_t() = delete;

  ellipse_t(size_t dim) : dim(dim), num(0), sampleIdx(0), mean(dim, 0.0), cov(dim * dim, 0.0), invCov(dim * dim, 0.0), axes(dim * dim, 0.0), evals(dim, 0.0), paxes(dim * dim, 0.0), volume(0.0), pointVolume(0.0){};

  /**
   * @brief Init d-dimensional unit sphere.
   */
  void initSphere();

  /**
   * @brief Dimension of ellipsoid.
  */
  size_t dim;

  /**
   * @brief Number samples in ellipse.
   */
  size_t num;

  /** 
   * @brief Indices of samples from live data set.
   */
  std::vector<size_t> sampleIdx;

  /** 
   * @brief Mean vector of samples in ellipse.
   */
  std::vector<double> mean;

  /**
    * @brief Covariance Matrix of samples in ellipse.
   */
  std::vector<double> cov;

  /**
    * @brief Inverse of Covariance Matrix.
   */
  std::vector<double> invCov;

  /**
    * @brief Axes of the ellipse.
   */
  std::vector<double> axes;

  /**
    * @brief Eigenvalues of the ellipse.
   */
  std::vector<double> evals;

  /**
    * @brief Principal axes of the ellipse.
   */
  std::vector<double> paxes;

  /**
   * @brief Volume estimated from covariance.
   */
  double volume;

  /**
   * @brief 'True' volume from which the subset of samples were sampled from.
   */
  double pointVolume;
};

class Nested : public Sampler
{
  private:
  /*
  * @brief Seed for the shuffle randomizer
  */
  size_t _shuffleSeed;

  /*
  * @brief Storing ellipses (only relevant for Multi Ellipsoidal sampling).
  */
  std::vector<ellipse_t> _ellipseVector;

  /*
  * @brief Init and run first Generation.
  */
  void runFirstGeneration();

  /*
  * @brief Prepare Generation before evaluation, update proposals.
  */
  void prepareGeneration();

  /*
   * @brief Transformation from unit domain into prior domain.
  */
  void priorTransform(std::vector<double> &sample) const;

  /*
  * @brief Generate new candidates to evaluate.
  */
  void generateCandidates();

  /** 
  * @brief Generate new samples uniformly in Box
  */
  void generateCandidatesFromBox();

  /** 
  * @brief Generates a sample uniformly in Ellipse
  */
  void generateSampleFromEllipse(const ellipse_t &ellipse, std::vector<double> &sample) const;

  /** 
  * @brief Generate new samples uniformly in Ellipse
  */
  void generateCandidatesFromEllipse();

  /** 
  * @brief Generate new samples uniformly from multiple Ellipses
  */
  void generateCandidatesFromMultiEllipse();

  /*
  * @brief Process Generation after receiving all results.
  */
  bool processGeneration();

  /*
  * @brief Add all live samples to sample data base.
  */
  void consumeLiveSamples();

  /*
  * @brief Updates bounding Box.
  */
  void updateBox();

  /*
  * @brief Ascending sort of live sample ranks based on evaluation.
 */
  void sortLiveSamplesAscending();

  /*
  * @brief Add sample to discard to sample database.
 */
  void updateSampleDatabase(size_t sampleIdx);

  /*
  * @brief Generate posterior distribution from sample data base.
  */
  void generatePosterior();

  /*
  * @brief Calculate L2 distance between two vectors.
  */
  double l2distance(const std::vector<double> &sampleOne, const std::vector<double> &sampleTwo) const;

  /*
  * @brief Updates bounding Ellipse.
  */
  bool updateEllipse(ellipse_t &ellipse) const;

  /*
  * @brief Updates ellipses based on Multi Nest.
  */
  void updateMultiEllipse();

  /*
  * @brief Initializes the ellipse vector with one ellipse..
  */
  void initEllipseVector();

  /*
  * @brief Applies k-means clustering (k=2) and fills cluster vectors with samples.
  */
  bool kmeansClustering(const ellipse_t &parent, size_t maxIter, ellipse_t &childOne, ellipse_t &childTwo) const;

  /*
  * @brief Udates the mean vector of ellipse argument.
  */
  void updateEllipseMean(ellipse_t &ellipse) const;

  /*
  * @brief Udates the covariance matrix of input ellipse.
  */
  bool updateEllipseCov(ellipse_t &ellipse) const;

  /*
  * @brief Updates volume and the axes of the ellipse.
  */
  bool updateEllipseVolume(ellipse_t &ellipse) const;

  /*
  * @brief Calculates Mahalanobis metric of sample and ellipse.
  */
  double mahalanobisDistance(const std::vector<double> &sample, const ellipse_t &ellipse) const;

  /*
  * @brief Calculates weighted Mahalanobis metric of sample and ellipse.
  */
  double weightedMahalanobisDistance(const std::vector<double> &sample, const ellipse_t &ellipse) const;

  /*
  * @brief Reassigns samples from parent to childs based on weighted Mahalanobis distance.
  */
  size_t reassignSamples(ellipse_t &childOne, ellipse_t &childTwo) const;

  /*
  * @brief Calculate effective number of samples.
  * @return the number of effective samples
  */
  double calcEffectiveSamples() const;

 /*
  * @brief Checks if sample is inside d dimensional unit cube.
  */
  bool insideUnitCube(const std::vector<double>& sample) const;
  
  /*
  * @brief Safely adding two values that are in log space. Returns in log space.
  * @param logx logx
  * @param logy logy
  * return The operation result
  */
  double safeLogPlus(double logx, double logy) const;

  /*
  * @brief Safely subtracting logy from logx. Returns in log space.
  * @param logx logx
  * @param logy logy
  * return The operation result
  */
  double safeLogMinus(double logx, double logy) const;

  public:
  /**
  * @brief Configures Sampler.
  */
  void setInitialConfiguration() override;

  /**
  * @brief Main solver loop.
  */
  void runGeneration() override;

  /**
  * @brief Console Output before generation runs.
  */
  void printGenerationBefore() override;

  /**
  * @brief Console output after generation.
  */
  void printGenerationAfter() override;

  /**
  * @brief Final console output at termination.
  */
  void finalize() override;
};

} // namespace sampler
} // namespace solver
} // namespace korali

#endif // _KORALI_SOLVER_NESTED_HPP_
