#ifndef _KORALI_PROBLEM_HIERARCHICALLATENTREFERENCE_HPP_
#define _KORALI_PROBLEM_HIERARCHICALLATENTREFERENCE_HPP_

#include "engine.hpp"
#include "modules/experiment/experiment.hpp"
#include "modules/problem/bayesian/bayesian.hpp"
#include "modules/problem/bayesian/latent/hierarchicalLatentLowlevel/hierarchicalLatentLowlevel.hpp"
#include "modules/problem/bayesian/latent/latent.hpp"

//#include <memory>

namespace korali
{
namespace problem
{
namespace bayesian
{
namespace latent
{
class HierarchicalLatentReference : public korali::problem::bayesian::Latent
{
  private:
  const double _log2pi = 1.83787706640934533908193770912476;

  /**
  * @brief Precomputes the square distance between two values (f and y) normalized by a third value (g).
  *         Scalar version of the same function in bayesian/reference.
  * @param f Single evaluation f(x, theta)
  * @param g The normalization
  * @param y "Measurement"
  * @return Normalized square distance of the vectors
  */
  double compute_normalized_sse(double f, double g, double y);

  /**
  * @brief An implementation of the normal likelihood y~N(f,g), where f ang g are provided by the user.
  * @param sample A Korali Sample
  */
  void loglikelihoodNormal(korali::Sample &sample);

  /**
  * @brief An implementation of the normal likelihood y~N(f,g) truncated at zero, where f ang g are provided by the user.
  * @param sample A Korali Sample
  */
  void loglikelihoodPositiveNormal(korali::Sample &sample);

  /**
  * @brief Negative Binomial likelihood parametrized by mean and dispersion.
  * @param sample A Korali Sample
  */
  void loglikelihoodNegativeBinomial(korali::Sample &sample);

  public:
  /** @brief The lowlevel problem containing actual calculations. */
  korali::problem::bayesian::latent::HierarchicalLatentLowlevel *_lowlevelProblem;

  /**
  * @brief The problem initialization; here, create hyperparameter variables and set up index lists to
           find both types of variables
 */
  void initialize() override;

  /**
  * @brief Call destructor of sub-problem, just in case we want to do some de-allocation there
 */
  ~HierarchicalLatentReference();

/**
    @brief Evaluate the conditional log-likelihood of one data point, given its reference function value.
           How it is calculated depends on the _likelihoodModel.
     @param sample: sample["Latent Variables"] should contain one latent variable vector. sample["Data Point"] should
                    contain a single data point (a vector, can be 1-D), where the last dimension is expected to contain
                    the reference evaluation.
     @returns: Will set sample["logLikelihood"].
   */
  std::function<void(korali::Sample & s)> conditionalLogLikelihoodFunction;
//  void conditionalLogLikelihoodFunction(korali::Sample &sample);

  /**
    @brief Evaluate each log-likelihood log(p(data for individual i | latent variables i)) across all data points
            assigned to the individual, given latent variables.
            Uses sample["Latent Variables"] which must be a vector of vectors of latent variables (one vector per individual).
     @param sample: sample["Latent Variables"] should contain a list of lists / vector of vectors, one latent variable vector for each individual.
     @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
     @returns : sample['Log Likelihood'], a list/vector with one log-likelihood per individual.
 */
  void evaluateLoglikelihood_(korali::Sample &sample, bool zForm = true);
  /**
    @brief Same as evaluateLogLikelihood_(..., zForm = true)
    @param sample: See other function description
    */
  void evaluateLoglikelihood(korali::Sample &sample) override;

  /**
  * @brief Evaluate the conditional log-likelihood of one data point, given its reference function value.
  *         How it is calculated depends on the _likelihoodModel.
  * @param sample: Should contain fields "Latent Variables" and "Data Point". The last dimension of "Data Point" is
  *                 expected to be the reference function value, that is, point = [x1, x2, ... xd, y] where
  *                 our x values have d dimensions.
  */
  void evaluateLoglikelihoodSingle(korali::Sample &sample);

  /**
  * @brief Evaluate log of p(latent | hyperparameters), hyperparameter-dependent prior over each *transformed* latent variable.
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"]. or
                    ["Covariance Cholesky Decomposition"]. Here, "Mean" should be a vector (size := n), "Covariance Matrix"
                     or "Covariance Cholesky Decomposition" should be an nxn vector of vectors. (No special encoding of the covariance.)
                    "Latent Variables" should be a vector of vectors, one * transformed * latent variable vector per individual. The order is
                    assumed to be the same as the order of variables according to their indices at problem definition
                    (["Variables"][THE_INDEX]["some property"] = ...).
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
    @param cholesky: If true, the function expects a cholesky-decomposed covariance matrix in
                    sample["Covariance Cholesky Decomposition"]. If false, expects a non-decomposed covariance in
                    sample["Covariance Matrix"].
  * @returns sample["Log Prior"], a vector, with one log-prior for each latent variable.
 */
  void evaluateLogPrior_(korali::Sample &sample, bool zForm = true, bool cholesky = true);
  /**
    @brief Same as evaluateLogPrior_(..., zForm = true, cholesky = true).
    @param sample: See other function description
    */
  void evaluateLogPrior(korali::Sample &sample) override;

  /**
  * @brief Evaluate the total log-probability p(all data | all latent) * p(latent | hyperparameters).
            log[ p(all data | all latent) * p(all latent | hyperparameters) ]
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"] or
                    ["Covariance Cholesky Decomposition"].
                    Data was given at problem creation.
                    "Mean" should be a vector (size := n), "Covariance Matrix"/ "Covariance Cholesky Decomposition" should
                    be an nxn vector of vectors. (No special encoding of the cov, except as cholesky decomposition.)
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
    @param cholesky: If true, the function expects a cholesky-decomposed covariance matrix in
                    sample["Covariance Cholesky Decomposition"]. If false, expects a non-decomposed covariance in
                    sample["Covariance Matrix"].
     @returns sample["Log Posterior"], a single value.
 */
  void evaluateLogPosterior_(korali::Sample &sample, bool zForm = true, bool cholesky = true);
  /**
    @brief Same as evaluateLogPosterior_(..., zForm = true, cholesky = true).
    @param sample: See other function description
    */
  void evaluateLogPosterior(korali::Sample &sample) override;

  /// @brief Korali experiment needed to create the sub-problem
  korali::Experiment _koraliExperiment;

  /**
 * @brief Korali engine needed to initialize the lowlevel problem / experiment.
 */
  korali::Engine _koraliEngine;
};

} // namespace latent
} // namespace bayesian
} // namespace problem
} // namespace korali

#endif // _KORALI_PROBLEM_HIERARCHICALLATENTREFERENCE_HPP_
